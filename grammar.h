#ifndef GRAMMAR_H
#define GRAMMAR_H
#include <stdlib.h>
#include <string.h>
#include "parserDef.h"

Grammar getLanguageGrammar(){
	RuleRightSideElement otherFunctions = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*otherFunctions = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_OtherFunctions};
	RuleRightSideElement mainFunction = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*mainFunction = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_MainFunction};
	RuleRightSideElement *rhs0 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 2);
	memcpy(rhs0, (RuleRightSideElement[]) {otherFunctions, mainFunction, }, sizeof(struct ruleRightSideElement) * 2);
	Rule rule0 = (Rule) malloc(sizeof(struct rule));
	*rule0 = (struct rule) {.lhs = NT_Program, .rhs = rhs0, .rhsLength = 2};
	RuleRightSideElement tk_main = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_main = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_MAIN};
	RuleRightSideElement stmts = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*stmts = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_Stmts};
	RuleRightSideElement tk_end = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_end = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_END};
	RuleRightSideElement *rhs1 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 3);
	memcpy(rhs1, (RuleRightSideElement[]) {tk_main, stmts, tk_end, }, sizeof(struct ruleRightSideElement) * 3);
	Rule rule1 = (Rule) malloc(sizeof(struct rule));
	*rule1 = (struct rule) {.lhs = NT_MainFunction, .rhs = rhs1, .rhsLength = 3};
	RuleRightSideElement function = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*function = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_Function};
	RuleRightSideElement *rhs2 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 2);
	memcpy(rhs2, (RuleRightSideElement[]) {function, otherFunctions, }, sizeof(struct ruleRightSideElement) * 2);
	Rule rule2 = (Rule) malloc(sizeof(struct rule));
	*rule2 = (struct rule) {.lhs = NT_OtherFunctions, .rhs = rhs2, .rhsLength = 2};
	RuleRightSideElement eps = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*eps = (struct ruleRightSideElement) {true, true, .symbol.terminal = TK_ID};
	RuleRightSideElement *rhs3 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs3, (RuleRightSideElement[]) {eps, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule3 = (Rule) malloc(sizeof(struct rule));
	*rule3 = (struct rule) {.lhs = NT_OtherFunctions, .rhs = rhs3, .rhsLength = 1};
	RuleRightSideElement tk_funid = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_funid = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_FUNID};
	RuleRightSideElement inputPar = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*inputPar = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_InputPar};
	RuleRightSideElement outputPar = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*outputPar = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_OutputPar};
	RuleRightSideElement tk_sem = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_sem = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_SEM};
	RuleRightSideElement *rhs4 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 6);
	memcpy(rhs4, (RuleRightSideElement[]) {tk_funid, inputPar, outputPar, tk_sem, stmts, tk_end, }, sizeof(struct ruleRightSideElement) * 6);
	Rule rule4 = (Rule) malloc(sizeof(struct rule));
	*rule4 = (struct rule) {.lhs = NT_Function, .rhs = rhs4, .rhsLength = 6};
	RuleRightSideElement tk_input = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_input = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_INPUT};
	RuleRightSideElement tk_parameter = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_parameter = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_PARAMETER};
	RuleRightSideElement tk_list = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_list = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_LIST};
	RuleRightSideElement tk_sql = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_sql = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_SQL};
	RuleRightSideElement parameterList = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*parameterList = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_ParameterList};
	RuleRightSideElement tk_sqr = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_sqr = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_SQR};
	RuleRightSideElement *rhs5 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 6);
	memcpy(rhs5, (RuleRightSideElement[]) {tk_input, tk_parameter, tk_list, tk_sql, parameterList, tk_sqr, }, sizeof(struct ruleRightSideElement) * 6);
	Rule rule5 = (Rule) malloc(sizeof(struct rule));
	*rule5 = (struct rule) {.lhs = NT_InputPar, .rhs = rhs5, .rhsLength = 6};
	RuleRightSideElement *rhs6 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 6);
	memcpy(rhs6, (RuleRightSideElement[]) {tk_input, tk_parameter, tk_list, tk_sql, parameterList, tk_sqr, }, sizeof(struct ruleRightSideElement) * 6);
	Rule rule6 = (Rule) malloc(sizeof(struct rule));
	*rule6 = (struct rule) {.lhs = NT_OutputPar, .rhs = rhs6, .rhsLength = 6};
	RuleRightSideElement *rhs7 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs7, (RuleRightSideElement[]) {eps, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule7 = (Rule) malloc(sizeof(struct rule));
	*rule7 = (struct rule) {.lhs = NT_OutputPar, .rhs = rhs7, .rhsLength = 1};
	RuleRightSideElement dataType = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*dataType = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_DataType};
	RuleRightSideElement tk_id = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_id = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_ID};
	RuleRightSideElement remainingList = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*remainingList = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_RemainingList};
	RuleRightSideElement *rhs8 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 3);
	memcpy(rhs8, (RuleRightSideElement[]) {dataType, tk_id, remainingList, }, sizeof(struct ruleRightSideElement) * 3);
	Rule rule8 = (Rule) malloc(sizeof(struct rule));
	*rule8 = (struct rule) {.lhs = NT_ParameterList, .rhs = rhs8, .rhsLength = 3};
	RuleRightSideElement primitiveDatatype = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*primitiveDatatype = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_PrimitiveDatatype};
	RuleRightSideElement *rhs9 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs9, (RuleRightSideElement[]) {primitiveDatatype, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule9 = (Rule) malloc(sizeof(struct rule));
	*rule9 = (struct rule) {.lhs = NT_DataType, .rhs = rhs9, .rhsLength = 1};
	RuleRightSideElement constructedDatatype = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*constructedDatatype = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_ConstructedDatatype};
	RuleRightSideElement *rhs10 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs10, (RuleRightSideElement[]) {constructedDatatype, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule10 = (Rule) malloc(sizeof(struct rule));
	*rule10 = (struct rule) {.lhs = NT_DataType, .rhs = rhs10, .rhsLength = 1};
	RuleRightSideElement tk_int = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_int = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_INT};
	RuleRightSideElement *rhs11 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs11, (RuleRightSideElement[]) {tk_int, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule11 = (Rule) malloc(sizeof(struct rule));
	*rule11 = (struct rule) {.lhs = NT_PrimitiveDatatype, .rhs = rhs11, .rhsLength = 1};
	RuleRightSideElement tk_real = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_real = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_REAL};
	RuleRightSideElement *rhs12 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs12, (RuleRightSideElement[]) {tk_real, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule12 = (Rule) malloc(sizeof(struct rule));
	*rule12 = (struct rule) {.lhs = NT_PrimitiveDatatype, .rhs = rhs12, .rhsLength = 1};
	RuleRightSideElement tk_record = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_record = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_RECORD};
	RuleRightSideElement tk_ruid = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_ruid = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_RUID};
	RuleRightSideElement *rhs13 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 2);
	memcpy(rhs13, (RuleRightSideElement[]) {tk_record, tk_ruid, }, sizeof(struct ruleRightSideElement) * 2);
	Rule rule13 = (Rule) malloc(sizeof(struct rule));
	*rule13 = (struct rule) {.lhs = NT_ConstructedDatatype, .rhs = rhs13, .rhsLength = 2};
	RuleRightSideElement tk_union = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_union = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_UNION};
	RuleRightSideElement *rhs14 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 2);
	memcpy(rhs14, (RuleRightSideElement[]) {tk_union, tk_ruid, }, sizeof(struct ruleRightSideElement) * 2);
	Rule rule14 = (Rule) malloc(sizeof(struct rule));
	*rule14 = (struct rule) {.lhs = NT_ConstructedDatatype, .rhs = rhs14, .rhsLength = 2};
	RuleRightSideElement *rhs15 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs15, (RuleRightSideElement[]) {tk_ruid, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule15 = (Rule) malloc(sizeof(struct rule));
	*rule15 = (struct rule) {.lhs = NT_ConstructedDatatype, .rhs = rhs15, .rhsLength = 1};
	RuleRightSideElement tk_comma = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_comma = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_COMMA};
	RuleRightSideElement *rhs16 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 2);
	memcpy(rhs16, (RuleRightSideElement[]) {tk_comma, parameterList, }, sizeof(struct ruleRightSideElement) * 2);
	Rule rule16 = (Rule) malloc(sizeof(struct rule));
	*rule16 = (struct rule) {.lhs = NT_RemainingList, .rhs = rhs16, .rhsLength = 2};
	RuleRightSideElement *rhs17 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs17, (RuleRightSideElement[]) {eps, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule17 = (Rule) malloc(sizeof(struct rule));
	*rule17 = (struct rule) {.lhs = NT_RemainingList, .rhs = rhs17, .rhsLength = 1};
	RuleRightSideElement typeDefinitions = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*typeDefinitions = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_TypeDefinitions};
	RuleRightSideElement declaration = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*declaration = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_Declaration};
	RuleRightSideElement otherStmts = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*otherStmts = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_OtherStmts};
	RuleRightSideElement returnStmt = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*returnStmt = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_ReturnStmt};
	RuleRightSideElement *rhs18 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 4);
	memcpy(rhs18, (RuleRightSideElement[]) {typeDefinitions, declaration, otherStmts, returnStmt, }, sizeof(struct ruleRightSideElement) * 4);
	Rule rule18 = (Rule) malloc(sizeof(struct rule));
	*rule18 = (struct rule) {.lhs = NT_Stmts, .rhs = rhs18, .rhsLength = 4};
	RuleRightSideElement actualOrRedefined = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*actualOrRedefined = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_ActualOrRedefined};
	RuleRightSideElement *rhs19 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 2);
	memcpy(rhs19, (RuleRightSideElement[]) {actualOrRedefined, typeDefinitions, }, sizeof(struct ruleRightSideElement) * 2);
	Rule rule19 = (Rule) malloc(sizeof(struct rule));
	*rule19 = (struct rule) {.lhs = NT_TypeDefinitions, .rhs = rhs19, .rhsLength = 2};
	RuleRightSideElement *rhs20 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs20, (RuleRightSideElement[]) {eps, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule20 = (Rule) malloc(sizeof(struct rule));
	*rule20 = (struct rule) {.lhs = NT_TypeDefinitions, .rhs = rhs20, .rhsLength = 1};
	RuleRightSideElement typeDefinition = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*typeDefinition = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_TypeDefinition};
	RuleRightSideElement *rhs21 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs21, (RuleRightSideElement[]) {typeDefinition, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule21 = (Rule) malloc(sizeof(struct rule));
	*rule21 = (struct rule) {.lhs = NT_ActualOrRedefined, .rhs = rhs21, .rhsLength = 1};
	RuleRightSideElement definetypeStmt = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*definetypeStmt = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_DefinetypeStmt};
	RuleRightSideElement *rhs22 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs22, (RuleRightSideElement[]) {definetypeStmt, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule22 = (Rule) malloc(sizeof(struct rule));
	*rule22 = (struct rule) {.lhs = NT_ActualOrRedefined, .rhs = rhs22, .rhsLength = 1};
	RuleRightSideElement fieldDefinitions = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*fieldDefinitions = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_FieldDefinitions};
	RuleRightSideElement tk_endrecord = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_endrecord = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_ENDRECORD};
	RuleRightSideElement *rhs23 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 4);
	memcpy(rhs23, (RuleRightSideElement[]) {tk_record, tk_ruid, fieldDefinitions, tk_endrecord, }, sizeof(struct ruleRightSideElement) * 4);
	Rule rule23 = (Rule) malloc(sizeof(struct rule));
	*rule23 = (struct rule) {.lhs = NT_TypeDefinition, .rhs = rhs23, .rhsLength = 4};
	RuleRightSideElement tk_endunion = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_endunion = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_ENDUNION};
	RuleRightSideElement *rhs24 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 4);
	memcpy(rhs24, (RuleRightSideElement[]) {tk_union, tk_ruid, fieldDefinitions, tk_endunion, }, sizeof(struct ruleRightSideElement) * 4);
	Rule rule24 = (Rule) malloc(sizeof(struct rule));
	*rule24 = (struct rule) {.lhs = NT_TypeDefinition, .rhs = rhs24, .rhsLength = 4};
	RuleRightSideElement fieldDefinition = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*fieldDefinition = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_FieldDefinition};
	RuleRightSideElement moreFields = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*moreFields = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_MoreFields};
	RuleRightSideElement *rhs25 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 3);
	memcpy(rhs25, (RuleRightSideElement[]) {fieldDefinition, fieldDefinition, moreFields, }, sizeof(struct ruleRightSideElement) * 3);
	Rule rule25 = (Rule) malloc(sizeof(struct rule));
	*rule25 = (struct rule) {.lhs = NT_FieldDefinitions, .rhs = rhs25, .rhsLength = 3};
	RuleRightSideElement tk_type = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_type = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_TYPE};
	RuleRightSideElement tk_colon = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_colon = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_COLON};
	RuleRightSideElement tk_fieldid = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_fieldid = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_FIELDID};
	RuleRightSideElement *rhs26 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 5);
	memcpy(rhs26, (RuleRightSideElement[]) {tk_type, dataType, tk_colon, tk_fieldid, tk_sem, }, sizeof(struct ruleRightSideElement) * 5);
	Rule rule26 = (Rule) malloc(sizeof(struct rule));
	*rule26 = (struct rule) {.lhs = NT_FieldDefinition, .rhs = rhs26, .rhsLength = 5};
	RuleRightSideElement *rhs27 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 2);
	memcpy(rhs27, (RuleRightSideElement[]) {fieldDefinition, moreFields, }, sizeof(struct ruleRightSideElement) * 2);
	Rule rule27 = (Rule) malloc(sizeof(struct rule));
	*rule27 = (struct rule) {.lhs = NT_MoreFields, .rhs = rhs27, .rhsLength = 2};
	RuleRightSideElement *rhs28 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs28, (RuleRightSideElement[]) {eps, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule28 = (Rule) malloc(sizeof(struct rule));
	*rule28 = (struct rule) {.lhs = NT_MoreFields, .rhs = rhs28, .rhsLength = 1};
	RuleRightSideElement declarations = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*declarations = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_Declarations};
	RuleRightSideElement *rhs29 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 2);
	memcpy(rhs29, (RuleRightSideElement[]) {declaration, declarations, }, sizeof(struct ruleRightSideElement) * 2);
	Rule rule29 = (Rule) malloc(sizeof(struct rule));
	*rule29 = (struct rule) {.lhs = NT_Declarations, .rhs = rhs29, .rhsLength = 2};
	RuleRightSideElement *rhs30 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs30, (RuleRightSideElement[]) {eps, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule30 = (Rule) malloc(sizeof(struct rule));
	*rule30 = (struct rule) {.lhs = NT_Declarations, .rhs = rhs30, .rhsLength = 1};
	RuleRightSideElement globalOrNot = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*globalOrNot = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_GlobalOrNot};
	RuleRightSideElement *rhs31 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 6);
	memcpy(rhs31, (RuleRightSideElement[]) {tk_type, dataType, tk_colon, tk_id, globalOrNot, tk_sem, }, sizeof(struct ruleRightSideElement) * 6);
	Rule rule31 = (Rule) malloc(sizeof(struct rule));
	*rule31 = (struct rule) {.lhs = NT_Declaration, .rhs = rhs31, .rhsLength = 6};
	RuleRightSideElement tk_global = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_global = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_GLOBAL};
	RuleRightSideElement *rhs32 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 2);
	memcpy(rhs32, (RuleRightSideElement[]) {tk_colon, tk_global, }, sizeof(struct ruleRightSideElement) * 2);
	Rule rule32 = (Rule) malloc(sizeof(struct rule));
	*rule32 = (struct rule) {.lhs = NT_GlobalOrNot, .rhs = rhs32, .rhsLength = 2};
	RuleRightSideElement *rhs33 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs33, (RuleRightSideElement[]) {eps, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule33 = (Rule) malloc(sizeof(struct rule));
	*rule33 = (struct rule) {.lhs = NT_GlobalOrNot, .rhs = rhs33, .rhsLength = 1};
	RuleRightSideElement stmt = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*stmt = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_Stmt};
	RuleRightSideElement *rhs34 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 2);
	memcpy(rhs34, (RuleRightSideElement[]) {stmt, otherStmts, }, sizeof(struct ruleRightSideElement) * 2);
	Rule rule34 = (Rule) malloc(sizeof(struct rule));
	*rule34 = (struct rule) {.lhs = NT_OtherStmts, .rhs = rhs34, .rhsLength = 2};
	RuleRightSideElement *rhs35 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs35, (RuleRightSideElement[]) {eps, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule35 = (Rule) malloc(sizeof(struct rule));
	*rule35 = (struct rule) {.lhs = NT_OtherStmts, .rhs = rhs35, .rhsLength = 1};
	RuleRightSideElement assignmentStmt = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*assignmentStmt = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_AssignmentStmt};
	RuleRightSideElement *rhs36 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs36, (RuleRightSideElement[]) {assignmentStmt, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule36 = (Rule) malloc(sizeof(struct rule));
	*rule36 = (struct rule) {.lhs = NT_Stmt, .rhs = rhs36, .rhsLength = 1};
	RuleRightSideElement iterativeStmt = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*iterativeStmt = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_IterativeStmt};
	RuleRightSideElement *rhs37 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs37, (RuleRightSideElement[]) {iterativeStmt, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule37 = (Rule) malloc(sizeof(struct rule));
	*rule37 = (struct rule) {.lhs = NT_Stmt, .rhs = rhs37, .rhsLength = 1};
	RuleRightSideElement conditionalStmt = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*conditionalStmt = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_ConditionalStmt};
	RuleRightSideElement *rhs38 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs38, (RuleRightSideElement[]) {conditionalStmt, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule38 = (Rule) malloc(sizeof(struct rule));
	*rule38 = (struct rule) {.lhs = NT_Stmt, .rhs = rhs38, .rhsLength = 1};
	RuleRightSideElement ioStmt = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*ioStmt = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_IoStmt};
	RuleRightSideElement *rhs39 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs39, (RuleRightSideElement[]) {ioStmt, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule39 = (Rule) malloc(sizeof(struct rule));
	*rule39 = (struct rule) {.lhs = NT_Stmt, .rhs = rhs39, .rhsLength = 1};
	RuleRightSideElement funCallStmt = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*funCallStmt = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_FunCallStmt};
	RuleRightSideElement *rhs40 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs40, (RuleRightSideElement[]) {funCallStmt, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule40 = (Rule) malloc(sizeof(struct rule));
	*rule40 = (struct rule) {.lhs = NT_Stmt, .rhs = rhs40, .rhsLength = 1};
	RuleRightSideElement singleOrRecId = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*singleOrRecId = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_SingleOrRecId};
	RuleRightSideElement tk_assignop = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_assignop = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_ASSIGNOP};
	RuleRightSideElement arithmeticExpression = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*arithmeticExpression = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_ArithmeticExpression};
	RuleRightSideElement *rhs41 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 4);
	memcpy(rhs41, (RuleRightSideElement[]) {singleOrRecId, tk_assignop, arithmeticExpression, tk_sem, }, sizeof(struct ruleRightSideElement) * 4);
	Rule rule41 = (Rule) malloc(sizeof(struct rule));
	*rule41 = (struct rule) {.lhs = NT_AssignmentStmt, .rhs = rhs41, .rhsLength = 4};
	RuleRightSideElement optionSingleConstructed = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*optionSingleConstructed = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_OptionSingleConstructed};
	RuleRightSideElement *rhs42 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 2);
	memcpy(rhs42, (RuleRightSideElement[]) {tk_id, optionSingleConstructed, }, sizeof(struct ruleRightSideElement) * 2);
	Rule rule42 = (Rule) malloc(sizeof(struct rule));
	*rule42 = (struct rule) {.lhs = NT_SingleOrRecId, .rhs = rhs42, .rhsLength = 2};
	RuleRightSideElement *rhs43 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs43, (RuleRightSideElement[]) {eps, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule43 = (Rule) malloc(sizeof(struct rule));
	*rule43 = (struct rule) {.lhs = NT_OptionSingleConstructed, .rhs = rhs43, .rhsLength = 1};
	RuleRightSideElement oneExpansion = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*oneExpansion = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_OneExpansion};
	RuleRightSideElement moreExpansions = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*moreExpansions = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_MoreExpansions};
	RuleRightSideElement *rhs44 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 2);
	memcpy(rhs44, (RuleRightSideElement[]) {oneExpansion, moreExpansions, }, sizeof(struct ruleRightSideElement) * 2);
	Rule rule44 = (Rule) malloc(sizeof(struct rule));
	*rule44 = (struct rule) {.lhs = NT_OptionSingleConstructed, .rhs = rhs44, .rhsLength = 2};
	RuleRightSideElement tk_dot = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_dot = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_DOT};
	RuleRightSideElement *rhs45 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 2);
	memcpy(rhs45, (RuleRightSideElement[]) {tk_dot, tk_fieldid, }, sizeof(struct ruleRightSideElement) * 2);
	Rule rule45 = (Rule) malloc(sizeof(struct rule));
	*rule45 = (struct rule) {.lhs = NT_OneExpansion, .rhs = rhs45, .rhsLength = 2};
	RuleRightSideElement *rhs46 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 2);
	memcpy(rhs46, (RuleRightSideElement[]) {oneExpansion, moreExpansions, }, sizeof(struct ruleRightSideElement) * 2);
	Rule rule46 = (Rule) malloc(sizeof(struct rule));
	*rule46 = (struct rule) {.lhs = NT_MoreExpansions, .rhs = rhs46, .rhsLength = 2};
	RuleRightSideElement *rhs47 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs47, (RuleRightSideElement[]) {eps, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule47 = (Rule) malloc(sizeof(struct rule));
	*rule47 = (struct rule) {.lhs = NT_MoreExpansions, .rhs = rhs47, .rhsLength = 1};
	RuleRightSideElement outputParameters = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*outputParameters = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_OutputParameters};
	RuleRightSideElement tk_call = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_call = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_CALL};
	RuleRightSideElement tk_with = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_with = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_WITH};
	RuleRightSideElement tk_parameters = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_parameters = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_PARAMETERS};
	RuleRightSideElement inputParameters = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*inputParameters = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_InputParameters};
	RuleRightSideElement *rhs48 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 7);
	memcpy(rhs48, (RuleRightSideElement[]) {outputParameters, tk_call, tk_funid, tk_with, tk_parameters, inputParameters, tk_sem, }, sizeof(struct ruleRightSideElement) * 7);
	Rule rule48 = (Rule) malloc(sizeof(struct rule));
	*rule48 = (struct rule) {.lhs = NT_FunCallStmt, .rhs = rhs48, .rhsLength = 7};
	RuleRightSideElement idList = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*idList = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_IdList};
	RuleRightSideElement *rhs49 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 4);
	memcpy(rhs49, (RuleRightSideElement[]) {tk_sql, idList, tk_sqr, tk_assignop, }, sizeof(struct ruleRightSideElement) * 4);
	Rule rule49 = (Rule) malloc(sizeof(struct rule));
	*rule49 = (struct rule) {.lhs = NT_OutputParameters, .rhs = rhs49, .rhsLength = 4};
	RuleRightSideElement *rhs50 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs50, (RuleRightSideElement[]) {eps, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule50 = (Rule) malloc(sizeof(struct rule));
	*rule50 = (struct rule) {.lhs = NT_OutputParameters, .rhs = rhs50, .rhsLength = 1};
	RuleRightSideElement *rhs51 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 3);
	memcpy(rhs51, (RuleRightSideElement[]) {tk_sql, idList, tk_sqr, }, sizeof(struct ruleRightSideElement) * 3);
	Rule rule51 = (Rule) malloc(sizeof(struct rule));
	*rule51 = (struct rule) {.lhs = NT_InputParameters, .rhs = rhs51, .rhsLength = 3};
	RuleRightSideElement tk_while = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_while = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_WHILE};
	RuleRightSideElement tk_op = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_op = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_OP};
	RuleRightSideElement booleanExpression = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*booleanExpression = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_BooleanExpression};
	RuleRightSideElement tk_cl = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_cl = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_CL};
	RuleRightSideElement tk_endwhile = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_endwhile = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_ENDWHILE};
	RuleRightSideElement *rhs52 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 7);
	memcpy(rhs52, (RuleRightSideElement[]) {tk_while, tk_op, booleanExpression, tk_cl, stmt, otherStmts, tk_endwhile, }, sizeof(struct ruleRightSideElement) * 7);
	Rule rule52 = (Rule) malloc(sizeof(struct rule));
	*rule52 = (struct rule) {.lhs = NT_IterativeStmt, .rhs = rhs52, .rhsLength = 7};
	RuleRightSideElement tk_if = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_if = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_IF};
	RuleRightSideElement tk_then = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_then = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_THEN};
	RuleRightSideElement elsePart = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*elsePart = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_ElsePart};
	RuleRightSideElement tk_endif = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_endif = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_ENDIF};
	RuleRightSideElement *rhs53 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 9);
	memcpy(rhs53, (RuleRightSideElement[]) {tk_if, tk_op, booleanExpression, tk_cl, tk_then, stmt, otherStmts, elsePart, tk_endif, }, sizeof(struct ruleRightSideElement) * 9);
	Rule rule53 = (Rule) malloc(sizeof(struct rule));
	*rule53 = (struct rule) {.lhs = NT_ConditionalStmt, .rhs = rhs53, .rhsLength = 9};
	RuleRightSideElement tk_else = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_else = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_ELSE};
	RuleRightSideElement *rhs54 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 3);
	memcpy(rhs54, (RuleRightSideElement[]) {tk_else, stmt, otherStmts, }, sizeof(struct ruleRightSideElement) * 3);
	Rule rule54 = (Rule) malloc(sizeof(struct rule));
	*rule54 = (struct rule) {.lhs = NT_ElsePart, .rhs = rhs54, .rhsLength = 3};
	RuleRightSideElement *rhs55 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs55, (RuleRightSideElement[]) {eps, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule55 = (Rule) malloc(sizeof(struct rule));
	*rule55 = (struct rule) {.lhs = NT_ElsePart, .rhs = rhs55, .rhsLength = 1};
	RuleRightSideElement tk_read = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_read = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_READ};
	RuleRightSideElement var = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*var = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_Var};
	RuleRightSideElement *rhs56 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 5);
	memcpy(rhs56, (RuleRightSideElement[]) {tk_read, tk_op, var, tk_cl, tk_sem, }, sizeof(struct ruleRightSideElement) * 5);
	Rule rule56 = (Rule) malloc(sizeof(struct rule));
	*rule56 = (struct rule) {.lhs = NT_IoStmt, .rhs = rhs56, .rhsLength = 5};
	RuleRightSideElement tk_write = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_write = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_WRITE};
	RuleRightSideElement *rhs57 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 5);
	memcpy(rhs57, (RuleRightSideElement[]) {tk_write, tk_op, var, tk_cl, tk_sem, }, sizeof(struct ruleRightSideElement) * 5);
	Rule rule57 = (Rule) malloc(sizeof(struct rule));
	*rule57 = (struct rule) {.lhs = NT_IoStmt, .rhs = rhs57, .rhsLength = 5};
	RuleRightSideElement term = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*term = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_Term};
	RuleRightSideElement moreTerms = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*moreTerms = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_MoreTerms};
	RuleRightSideElement *rhs58 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 2);
	memcpy(rhs58, (RuleRightSideElement[]) {term, moreTerms, }, sizeof(struct ruleRightSideElement) * 2);
	Rule rule58 = (Rule) malloc(sizeof(struct rule));
	*rule58 = (struct rule) {.lhs = NT_ArithmeticExpression, .rhs = rhs58, .rhsLength = 2};
	RuleRightSideElement *rhs59 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 3);
	memcpy(rhs59, (RuleRightSideElement[]) {tk_op, arithmeticExpression, tk_cl, }, sizeof(struct ruleRightSideElement) * 3);
	Rule rule59 = (Rule) malloc(sizeof(struct rule));
	*rule59 = (struct rule) {.lhs = NT_ArithmeticExpression, .rhs = rhs59, .rhsLength = 3};
	RuleRightSideElement *rhs60 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs60, (RuleRightSideElement[]) {var, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule60 = (Rule) malloc(sizeof(struct rule));
	*rule60 = (struct rule) {.lhs = NT_ArithmeticExpression, .rhs = rhs60, .rhsLength = 1};
	RuleRightSideElement lowPrecedenceOperator = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*lowPrecedenceOperator = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_LowPrecedenceOperator};
	RuleRightSideElement *rhs61 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 3);
	memcpy(rhs61, (RuleRightSideElement[]) {lowPrecedenceOperator, term, moreTerms, }, sizeof(struct ruleRightSideElement) * 3);
	Rule rule61 = (Rule) malloc(sizeof(struct rule));
	*rule61 = (struct rule) {.lhs = NT_MoreTerms, .rhs = rhs61, .rhsLength = 3};
	RuleRightSideElement *rhs62 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs62, (RuleRightSideElement[]) {eps, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule62 = (Rule) malloc(sizeof(struct rule));
	*rule62 = (struct rule) {.lhs = NT_MoreTerms, .rhs = rhs62, .rhsLength = 1};
	RuleRightSideElement factor = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*factor = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_Factor};
	RuleRightSideElement moreFactors = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*moreFactors = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_MoreFactors};
	RuleRightSideElement *rhs63 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 2);
	memcpy(rhs63, (RuleRightSideElement[]) {factor, moreFactors, }, sizeof(struct ruleRightSideElement) * 2);
	Rule rule63 = (Rule) malloc(sizeof(struct rule));
	*rule63 = (struct rule) {.lhs = NT_Term, .rhs = rhs63, .rhsLength = 2};
	RuleRightSideElement highPrecedenceOperator = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*highPrecedenceOperator = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_HighPrecedenceOperator};
	RuleRightSideElement *rhs64 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 3);
	memcpy(rhs64, (RuleRightSideElement[]) {highPrecedenceOperator, factor, moreFactors, }, sizeof(struct ruleRightSideElement) * 3);
	Rule rule64 = (Rule) malloc(sizeof(struct rule));
	*rule64 = (struct rule) {.lhs = NT_MoreFactors, .rhs = rhs64, .rhsLength = 3};
	RuleRightSideElement *rhs65 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs65, (RuleRightSideElement[]) {eps, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule65 = (Rule) malloc(sizeof(struct rule));
	*rule65 = (struct rule) {.lhs = NT_MoreFactors, .rhs = rhs65, .rhsLength = 1};
	RuleRightSideElement *rhs66 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 3);
	memcpy(rhs66, (RuleRightSideElement[]) {tk_op, arithmeticExpression, tk_cl, }, sizeof(struct ruleRightSideElement) * 3);
	Rule rule66 = (Rule) malloc(sizeof(struct rule));
	*rule66 = (struct rule) {.lhs = NT_Factor, .rhs = rhs66, .rhsLength = 3};
	RuleRightSideElement *rhs67 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs67, (RuleRightSideElement[]) {var, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule67 = (Rule) malloc(sizeof(struct rule));
	*rule67 = (struct rule) {.lhs = NT_Factor, .rhs = rhs67, .rhsLength = 1};
	RuleRightSideElement tk_mul = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_mul = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_MUL};
	RuleRightSideElement *rhs68 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs68, (RuleRightSideElement[]) {tk_mul, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule68 = (Rule) malloc(sizeof(struct rule));
	*rule68 = (struct rule) {.lhs = NT_HighPrecedenceOperator, .rhs = rhs68, .rhsLength = 1};
	RuleRightSideElement tk_div = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_div = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_DIV};
	RuleRightSideElement *rhs69 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs69, (RuleRightSideElement[]) {tk_div, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule69 = (Rule) malloc(sizeof(struct rule));
	*rule69 = (struct rule) {.lhs = NT_HighPrecedenceOperator, .rhs = rhs69, .rhsLength = 1};
	RuleRightSideElement tk_plus = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_plus = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_PLUS};
	RuleRightSideElement *rhs70 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs70, (RuleRightSideElement[]) {tk_plus, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule70 = (Rule) malloc(sizeof(struct rule));
	*rule70 = (struct rule) {.lhs = NT_LowPrecedenceOperator, .rhs = rhs70, .rhsLength = 1};
	RuleRightSideElement tk_minus = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_minus = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_MINUS};
	RuleRightSideElement *rhs71 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs71, (RuleRightSideElement[]) {tk_minus, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule71 = (Rule) malloc(sizeof(struct rule));
	*rule71 = (struct rule) {.lhs = NT_LowPrecedenceOperator, .rhs = rhs71, .rhsLength = 1};
	RuleRightSideElement logicalOp = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*logicalOp = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_LogicalOp};
	RuleRightSideElement *rhs72 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 7);
	memcpy(rhs72, (RuleRightSideElement[]) {tk_op, booleanExpression, tk_cl, logicalOp, tk_op, booleanExpression, tk_cl, }, sizeof(struct ruleRightSideElement) * 7);
	Rule rule72 = (Rule) malloc(sizeof(struct rule));
	*rule72 = (struct rule) {.lhs = NT_BooleanExpression, .rhs = rhs72, .rhsLength = 7};
	RuleRightSideElement relationalOp = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*relationalOp = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_RelationalOp};
	RuleRightSideElement *rhs73 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 3);
	memcpy(rhs73, (RuleRightSideElement[]) {var, relationalOp, var, }, sizeof(struct ruleRightSideElement) * 3);
	Rule rule73 = (Rule) malloc(sizeof(struct rule));
	*rule73 = (struct rule) {.lhs = NT_BooleanExpression, .rhs = rhs73, .rhsLength = 3};
	RuleRightSideElement tk_not = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_not = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_NOT};
	RuleRightSideElement *rhs74 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 4);
	memcpy(rhs74, (RuleRightSideElement[]) {tk_not, tk_op, booleanExpression, tk_cl, }, sizeof(struct ruleRightSideElement) * 4);
	Rule rule74 = (Rule) malloc(sizeof(struct rule));
	*rule74 = (struct rule) {.lhs = NT_BooleanExpression, .rhs = rhs74, .rhsLength = 4};
	RuleRightSideElement tk_num = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_num = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_NUM};
	RuleRightSideElement *rhs75 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs75, (RuleRightSideElement[]) {tk_num, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule75 = (Rule) malloc(sizeof(struct rule));
	*rule75 = (struct rule) {.lhs = NT_Var, .rhs = rhs75, .rhsLength = 1};
	RuleRightSideElement tk_rnum = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_rnum = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_RNUM};
	RuleRightSideElement *rhs76 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs76, (RuleRightSideElement[]) {tk_rnum, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule76 = (Rule) malloc(sizeof(struct rule));
	*rule76 = (struct rule) {.lhs = NT_Var, .rhs = rhs76, .rhsLength = 1};
	RuleRightSideElement *rhs77 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs77, (RuleRightSideElement[]) {singleOrRecId, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule77 = (Rule) malloc(sizeof(struct rule));
	*rule77 = (struct rule) {.lhs = NT_Var, .rhs = rhs77, .rhsLength = 1};
	RuleRightSideElement tk_and = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_and = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_AND};
	RuleRightSideElement *rhs78 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs78, (RuleRightSideElement[]) {tk_and, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule78 = (Rule) malloc(sizeof(struct rule));
	*rule78 = (struct rule) {.lhs = NT_LogicalOp, .rhs = rhs78, .rhsLength = 1};
	RuleRightSideElement tk_or = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_or = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_OR};
	RuleRightSideElement *rhs79 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs79, (RuleRightSideElement[]) {tk_or, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule79 = (Rule) malloc(sizeof(struct rule));
	*rule79 = (struct rule) {.lhs = NT_LogicalOp, .rhs = rhs79, .rhsLength = 1};
	RuleRightSideElement tk_lt = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_lt = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_LT};
	RuleRightSideElement *rhs80 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs80, (RuleRightSideElement[]) {tk_lt, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule80 = (Rule) malloc(sizeof(struct rule));
	*rule80 = (struct rule) {.lhs = NT_RelationalOp, .rhs = rhs80, .rhsLength = 1};
	RuleRightSideElement tk_le = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_le = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_LE};
	RuleRightSideElement *rhs81 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs81, (RuleRightSideElement[]) {tk_le, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule81 = (Rule) malloc(sizeof(struct rule));
	*rule81 = (struct rule) {.lhs = NT_RelationalOp, .rhs = rhs81, .rhsLength = 1};
	RuleRightSideElement tk_eq = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_eq = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_EQ};
	RuleRightSideElement *rhs82 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs82, (RuleRightSideElement[]) {tk_eq, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule82 = (Rule) malloc(sizeof(struct rule));
	*rule82 = (struct rule) {.lhs = NT_RelationalOp, .rhs = rhs82, .rhsLength = 1};
	RuleRightSideElement tk_gt = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_gt = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_GT};
	RuleRightSideElement *rhs83 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs83, (RuleRightSideElement[]) {tk_gt, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule83 = (Rule) malloc(sizeof(struct rule));
	*rule83 = (struct rule) {.lhs = NT_RelationalOp, .rhs = rhs83, .rhsLength = 1};
	RuleRightSideElement tk_ge = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_ge = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_GE};
	RuleRightSideElement *rhs84 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs84, (RuleRightSideElement[]) {tk_ge, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule84 = (Rule) malloc(sizeof(struct rule));
	*rule84 = (struct rule) {.lhs = NT_RelationalOp, .rhs = rhs84, .rhsLength = 1};
	RuleRightSideElement tk_ne = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_ne = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_NE};
	RuleRightSideElement *rhs85 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs85, (RuleRightSideElement[]) {tk_ne, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule85 = (Rule) malloc(sizeof(struct rule));
	*rule85 = (struct rule) {.lhs = NT_RelationalOp, .rhs = rhs85, .rhsLength = 1};
	RuleRightSideElement tk_return = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_return = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_RETURN};
	RuleRightSideElement optionalReturn = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*optionalReturn = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_OptionalReturn};
	RuleRightSideElement *rhs86 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 3);
	memcpy(rhs86, (RuleRightSideElement[]) {tk_return, optionalReturn, tk_sem, }, sizeof(struct ruleRightSideElement) * 3);
	Rule rule86 = (Rule) malloc(sizeof(struct rule));
	*rule86 = (struct rule) {.lhs = NT_ReturnStmt, .rhs = rhs86, .rhsLength = 3};
	RuleRightSideElement *rhs87 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 3);
	memcpy(rhs87, (RuleRightSideElement[]) {tk_sql, idList, tk_sqr, }, sizeof(struct ruleRightSideElement) * 3);
	Rule rule87 = (Rule) malloc(sizeof(struct rule));
	*rule87 = (struct rule) {.lhs = NT_OptionalReturn, .rhs = rhs87, .rhsLength = 3};
	RuleRightSideElement *rhs88 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs88, (RuleRightSideElement[]) {eps, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule88 = (Rule) malloc(sizeof(struct rule));
	*rule88 = (struct rule) {.lhs = NT_OptionalReturn, .rhs = rhs88, .rhsLength = 1};
	RuleRightSideElement moreIds = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*moreIds = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_MoreIds};
	RuleRightSideElement *rhs89 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 2);
	memcpy(rhs89, (RuleRightSideElement[]) {tk_id, moreIds, }, sizeof(struct ruleRightSideElement) * 2);
	Rule rule89 = (Rule) malloc(sizeof(struct rule));
	*rule89 = (struct rule) {.lhs = NT_IdList, .rhs = rhs89, .rhsLength = 2};
	RuleRightSideElement *rhs90 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 2);
	memcpy(rhs90, (RuleRightSideElement[]) {tk_comma, idList, }, sizeof(struct ruleRightSideElement) * 2);
	Rule rule90 = (Rule) malloc(sizeof(struct rule));
	*rule90 = (struct rule) {.lhs = NT_MoreIds, .rhs = rhs90, .rhsLength = 2};
	RuleRightSideElement *rhs91 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs91, (RuleRightSideElement[]) {eps, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule91 = (Rule) malloc(sizeof(struct rule));
	*rule91 = (struct rule) {.lhs = NT_MoreIds, .rhs = rhs91, .rhsLength = 1};
	RuleRightSideElement tk_definetype = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_definetype = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_DEFINETYPE};
	RuleRightSideElement A = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*A = (struct ruleRightSideElement) {false, false, .symbol.nonTerminal = NT_A};
	RuleRightSideElement tk_as = (RuleRightSideElement) malloc(sizeof(struct ruleRightSideElement));
	*tk_as = (struct ruleRightSideElement) {false, true, .symbol.terminal = TK_AS};
	RuleRightSideElement *rhs92 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 5);
	memcpy(rhs92, (RuleRightSideElement[]) {tk_definetype, A, tk_ruid, tk_as, tk_ruid, }, sizeof(struct ruleRightSideElement) * 5);
	Rule rule92 = (Rule) malloc(sizeof(struct rule));
	*rule92 = (struct rule) {.lhs = NT_DefinetypeStmt, .rhs = rhs92, .rhsLength = 5};
	RuleRightSideElement *rhs93 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs93, (RuleRightSideElement[]) {tk_record, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule93 = (Rule) malloc(sizeof(struct rule));
	*rule93 = (struct rule) {.lhs = NT_A, .rhs = rhs93, .rhsLength = 1};
	RuleRightSideElement *rhs94 = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * 1);
	memcpy(rhs94, (RuleRightSideElement[]) {tk_union, }, sizeof(struct ruleRightSideElement) * 1);
	Rule rule94 = (Rule) malloc(sizeof(struct rule));
	*rule94 = (struct rule) {.lhs = NT_A, .rhs = rhs94, .rhsLength = 1};

	Rule *rules = (Rule *) malloc(sizeof(Rule) * 95);
	memcpy(rules, (Rule[]) {rule0, rule1, rule2, rule3, rule4, rule5, rule6, rule7, rule8, rule9, rule10, rule11, rule12, rule13, rule14, rule15, rule16, rule17, rule18, rule19, rule20, rule21, rule22, rule23, rule24, rule25, rule26, rule27, rule28, rule29, rule30, rule31, rule32, rule33, rule34, rule35, rule36, rule37, rule38, rule39, rule40, rule41, rule42, rule43, rule44, rule45, rule46, rule47, rule48, rule49, rule50, rule51, rule52, rule53, rule54, rule55, rule56, rule57, rule58, rule59, rule60, rule61, rule62, rule63, rule64, rule65, rule66, rule67, rule68, rule69, rule70, rule71, rule72, rule73, rule74, rule75, rule76, rule77, rule78, rule79, rule80, rule81, rule82, rule83, rule84, rule85, rule86, rule87, rule88, rule89, rule90, rule91, rule92, rule93, rule94, }, 95 * sizeof(Rule));
	Grammar languageGrammar = (Grammar) malloc(sizeof(struct grammar));
	*languageGrammar = (struct grammar) {NT_Program, 95, rules};
	return languageGrammar;
}

void freeGrammar(Grammar g) {
    if (g == NULL) return;

    // Array to track freed elements
    RuleRightSideElement *freedElements = (RuleRightSideElement *) malloc(sizeof(RuleRightSideElement) * (g->numRules * 10));
    int freedCount = 0;

    // Free each rule and its right-hand side elements
    for (int i = 0; i < g->numRules; i++) {
        Rule rule = g->rules[i];

        for (int j = 0; j < rule->rhsLength; j++) {
            RuleRightSideElement elem = rule->rhs[j];

            // Check if the element was already freed
            int alreadyFreed = 0;
            for (int k = 0; k < freedCount; k++) {
                if (freedElements[k] == elem) {
                    alreadyFreed = 1;
                    break;
                }
            }

            // Free only if not already freed
            if (!alreadyFreed) {
                freedElements[freedCount++] = elem;
                free(elem);
            }
        }

        free(rule->rhs);
        free(rule);
    }

    free(freedElements);
    free(g->rules);
    free(g);
}

#define NUM_NON_TERMINALS 107
#define NUM_RULES 95
#endif